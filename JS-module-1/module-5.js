//! Колбек-функції

//* Функції не відрізняються від чисел, рядків або масивів - це просто спеціальний тип даних(об'єкт вищого порядку),
//* значення, яке можна зберігати у змінній або передавати у якості аргументу в іншу функцію.

// function greet(name) {
//     return `Ласкаво просимо ${name}`;
// }

//*  Викликаємо функцію greet і виводимо результат у консоль
// console.log(greet("Sub Zero"));

//*  Виводимо функцію greet у консоль, не викликаючи її
// console.log(greet);

//* У першому лозі ми викликаємо функцію greet за допомогою круглих дужок, і в консоль виводиться результат її виконання.
//* У другому лозі передається посилання на функцію, а не результат виклику(відсутні круглі дужки), тому в консоль виводиться її тіло.
//* Це означає, що функцію можна присвоїти у змінну або передати як аругмент іншої функції.

//* Функція зворотного виклику (callback, колбек) - це функція, яка передається іншій функції як аргумент, а та, в свою чергу, викликає передану функцію.

//* Функція вищого порядку (higher order function) - функція, яка приймає у якості параметрів інші функції або повертає функцію у якості результату.


//* Колбек-функція

// function greet(name) {
//     console.log(`Ласкаво просимо ${name}.`);
// }

//*  Функція вищого порядку

// function registerGuest(name, callback) {
//     console.log(`Реєструємо гостя ${name}.`);
//     callback(name);
// }

// registerGuest("Манго", greet);

//* Ми передали посилання на функцію greet як аргумент, тому вона буде присвоєна в параметр callback і викликана всередині функції registerGuest за допомогою круглих дужок.
//* Ім'я параметра для колбека може бути довільним, головне пам'ятати, що значенням буде функція.

// ____________________________

//! Інлайн колбеки

//* Якщо колбек - функція - маленька, і потрібна тільки для передачі аргументом, її можна оголосити безпосередньо на момент виклику функції, в яку передаємо колбек.
//* Така функція буде доступна тільки у якості значення параметра і більше ніде в коді.

// function registerGuest(name, callback) {
//     console.log(`Реєструємо гостя ${name}.`);
//     callback(name);
// }

// registerGuest("Dima", function greet(name) {
//     console.log(`Ласкаво просимо ${name}.`);
// })

// ____________________________

//! Декілька колбеків

//* Функція може приймати будь - яку кількість колбеків.Наприклад, уявімо, що ми пишемо логіку прийняття дзвінків для телефону.
//* Програма повинна увімкнути автовідповідач, якщо абонент - недоступний, або з'єднати дзвінок в іншому випадку.
//* Доступність абонента будемо імітувати генератором випадкового числа, щоб між різними викликами функції можна було отримати різні результати.

// function processCall(recipient) {
//     * Імітуємо доступність абонента випадковим числом
//     const isRecipientAvailable = Marh.random() > 0.5;


//     if (!isRecipientAvailable) {
//         console.log(`Абонент ${recipient} недоступний, залиште повідомлення.`);
//         * Логіка активації автовідповідача
//     }
//     else {
//         console.log(`З'єднуємо з ${recipient}, очікуйте...`);
//         * Логіка прийняття дзвінка
//     }
// }

// processCall('Den');

//* Проблема такого підходу полягає у тому, що функція processCall робить занадто багато і прив'язує перевірку доступності абонента до двох заздалегідь визначених дій.

//* Ми могли б написати функцію таким чином, щоб вона повертала якесь значення, і потім за результатом її виконання, робити перевірки і виконувати потрібний код.
//* Але перевірки не стосуються зовнішнього коду і будуть його засмічувати.

//* Виконаємо рефакторинг функції таким чином, щоб вона приймала два колбеки onAvailable і onNotAvailable, і викликала їх за умовою.

// function processCall(recipient, onAvailable, onNotAvailable) {
//     * Імітуємо доступність абонента випадковим числом
//     const isRecipientAvailable = Math.random() > 0.5;
//     if (!isRecipientAvailable) {
//         onNotAvailable(recipient);
//         return;
//     }
//     onAvailable(recipient)
// }

// function takeCall(name) {
//     console.log(`З'єднуємо з ${name}, очікуйте...`);
// }

// function activateAnsweringMachine(name) {
//     console.log(`Абонент ${name} недоступний, залиште повідомлення.`);
// }

// function leaveHoloMessage(name) {
//     console.log(`Абонент ${name} недоступний, записуємо голограму.`);
// }

// processCall("Harry", takeCall, activateAnsweringMachine);

//* Колбеки застосовуються для обробки дій користувача на сторінці, на момент обробки запитів на сервер, виконання заздалегідь невідомих функцій тощо.
//* У цьому і полягає їх суть - це функції, призначені для відкладеного виконання.

// ____________________________

//! Абстрагування повторення

//* Абстракція - приховування деталей реалізації. Дозволяє думати про задачі на вищому (абстрактному) рівні.
//* Функції - це хороший спосіб побудови абстракцій.

//* Наприклад, скрипт виконує якусь дію певну кількість разів. З цією метою можна написати цикл for.

// for (let i = 0; i < 10; i += 1) {
//     console.log(i);
// }

//* Чи можемо ми абстрагувати «робити щось N разів» у якості функції? - так, напишемо функцію, яка викликає console.log() N разів.

// function repeatLog(n, name) {
//     for (let i = 0; i < n; i += 1){
//         console.log(`Hello! ${name}`);
//     }
// }

// repeatLog(8, "Dima");

//* Але що робити, якщо ми хочемо виконати щось, крім логування чисел ?
//* Оскільки «робити щось» можна уявити функцією, а функції - це просто значення, ми можемо передати дію як аргумент.

// function printValue(value) {
//     console.log(value);
// }

// function prettyPrint(value) {
//     console.log("Logging value: ", value);
// }

// function repeat(n, action) {
//     for (let i = 0; i < n; i += 1){
//         action(i)
//     }
// }

// repeat(8, prettyPrint);
// repeat(6, printValue);

// ____________________________________________________________

//! Метод forEach

//* Метод перебирання масиву, який використовується для заміни циклів for і for...of в роботі з колекцією даних.

//todo   массив.forEach(function callback(element, index, array)){
//todo   Тіло колбек-функції

//todo   }

//* Поелементо перебирає масив.

//* Викликає колбек-функцію для кожного елемента масиву.

//* Нічого не повертає.

//* Аргументи колбек - функції - це значення поточного елемента element, його індекс index і власне вихідний масив array.
//* Можна оголошувати тільки необхідні параметри, найчастіше - це елемент, головне не забувати про їх порядок.

// const numbers = [5, 10, 15, 20, 25];

//* Класичний for

// for (let i = 0; i < numbers.length; i += 1) {
//     console.log(`Індекс ${i}, значення ${numbers[i]}`);
// }

//* Метод перебирання forEach

// numbers.forEach(function (number, index) {
//     console.log(`Індекс ${index}, значення ${number}`)
// })

//* Єдиним випадком, коли варто використовувати цикли for або for...of для перебирання масиву, - це задачі з перериванням виконання циклу.
//* Перервати виконання методу forEach не можна, він завжди перебирає масив до кінця.

// ____________________________________________________________

//! Стрілочні функції

// Стрілочні функції мають скорочений, лаконічніший синтаксис, що зменшує обсяг коду, особливо коли функція маленька або якщо вона використовується як колбек.

// Усі стрілки створюються як функціональний вираз, і якщо функція - не анонімна, її необхідно присвоювати змінній.

//todo Звичайне оголошення функції

// function classicAdd(a, b, c) {
//   return a + b + c;
// }

//todo Те саме стрілочною функцією

// const arrowAdd = (a, b, c) => {
//     return a + b + c;
// }

//* Ключове слово function не використовується, замість цього відразу зазначається оголошення параметрів, після нього - символ => і тіло функції.

//* Якщо параметрів декілька, то вони перераховуються через кому в круглих дужках, між знаками дорівнює = і стрілкою =>.

// const add = (a, b, c) => {
//     return a + b + c;
// };

//* Якщо параметр один, його можна оголошувати без круглих дужок.

// const add = a => {
//     return a + 5;
// }

//* Якщо параметри відсутні, то обов'язково повинні бути порожні круглі дужки.

// const greet = () => {
//     console.log("Привіт!");
// }

// ____________________________

//! Неявне повернення

//* У стрілочної функції після символу => знаходиться її тіло. Існує два варіанти: з фігурними дужками і без них.

// const add = (a, b, c) => {
//     console.log(a, b, c);
//     return a + b + c;
// }

//* Якщо є фігурні дужки, і функція повинна повертати якесь значення, необхідно явно поставити return.
//* Це називається явне повернення(explicit return).
//* Такий синтаксис використовується у разі, якщо в тілі функції потрібно виконати ще якісь інструкції, крім повернення значення.

// const add = (a, b, c) => a + b + c

//* Якщо фігурні дужки відсутні, то повертається результат виразу, який стоїть після =>.
//* Це називається неявне повернення(implicit return).
//* У прикладі повернеться результат виразу додавання параметрів a, b і c.

//* Синтаксис неявного повернення суттєво скорочує «шум» оголошення функції з тілом і виразом, що повертається,
//* але доречний тільки тоді, коли в тілі функції не потрібно виконувати жодних додаткових інструкцій, крім повернення значення.

//* До
// function classicAdd(a, b, c) {
//   return a + b + c;
// }

//* Після
// const arrowAdd = (a, b, c) => a + b + c;

// ____________________________

//! Псевдомасив arguments

//* У стрілочних функцій немає локальної змінної arguments, що містить усі аргументи. Якщо необхідно зібрати всі аргументи в масив, використовується операція rest.

// const add = (...args) => {
//     console.log(args);
// }

// add(8, 4, 2,5);

// ____________________________

//! Стрілочні функції як колбеки

//* Анонімні стрілочні функції відмінно підходять як колбеки для перебираючих методів масиву завдяки коротшому синтаксису оголошення, особливо, якщо не потрібне тіло функції.

// const numbers = [5, 10, 15, 20, 25];

//* Оголошення функції

// numbers.forEach(function (number, index) {
//     console.log(`Індекс ${index}, значення ${number}`);
// })

//* Анонімна стрілочна функція

// number.forEach((number, index) => {
//     console.log(`Індекс ${index}, значення ${number}`);
// })

//* Стрілочну колбек-функцію також можна оголошувати окремо і передавати на неї посилання. Це варто робити, якщо одна функція використовується у декількох місцях програми або якщо вона громіздка.

// const numbers = [5, 10, 15, 20, 25]

// const logMessage = (number, index) => {
//     console.log(`Індекс ${index}, значення ${number}`);
// }

// numbers.forEach(logMessage);

// ____________________________________________________________

//! Різновиди коду


































